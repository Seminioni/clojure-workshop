# Chapter 2

ЯП такие как C++, Java, Python, Ruby всё ещё поощряют разработчика мутировать переменные и использовать переменные, т.е писать код так будто у нас всё ещё мало памяти

В Clojure мы работаем эксклюзивно с немутабельными структурами данных:
- Их безопасно можно передавать,
- Их легко создавать, 
- Они улучшают читаемость исходного кода

Иммутабельный - это тот, который не может быть изменен, тот который никогда не изменится

"Обновление" иммутабельной (неизменяемой) структуры данных создаёт новую, производную структуру данных из оригинальной. А оригинальная структура данных остаётся неизменной.

Те структуры данных, что сохраняются свои предыдущие версии называются **персистентными**

> Пока вы не программируете высокопроизводительную игру, использование иммутабельности легко перевешивает легкую потерю в производительности

## Simple Data Types
Strings  • Numbers • Booleans • Keywords • Nil — **иммутабельны**

### Strings
Строка создаётся с использованием двойных кавычек

В JVM стринга имеет java.lang.String класс и имплементирована через java.lang.Character

 **type** ф-ия возвращает текстовое представление типа данных 
 
 Через ф-ию `dir` можно посмотреть все ф-ии в неймспейсе
 
### Numbers
В Clojure числа имплементированы через `java.lang.Long` тип

В Clojure также есть отдельный тип для дробей
—  `clojure.lang.Ratio`

`user=> (type 3/4) -> 
clojure.lang.Ratio`

Любые числовые операции с числами с плавающей запятой будут производить такие же  *`float`* числа

`user=> (type (\* 1.0 2)) -> java.lang.Double`

В ClojureScript числа  — double-precision floating-point числа.

####  Exercise 2.01: The Obfuscation Machine

`(int (first (char-array s)))`

`char-array` создаёт массив чаров
`first` возвращает 1 элемент
`int` приводит к инту
`char` возвращает чар из кода
 `subs` называется от substring. возвращает подстроку 
 
 `(clojure.string/replace s #"\#\d+" (fn [s]
 		(decode-letter s number-of-words)))`

`s` - строка
`#"\#\d+"` - regex
`(fn [s] (decode-letter s number-of-words))` - коллбек 

### Symbols
`Symbol` — идентификатор ссылающийся на что-то

### Keywords
`Keyword` — специальные стринговые константы

Кейворды не ссылаются ни на что как символы

Кейворды используются как `ключи` в ассоциативной мапе типа "ключ-значение"

## Collections
 > Clojure — функциональный язык программирования который фокусируется на построении вычислений через вычисление функций нежели чем на построении каких-то своих типов данных и поведением присущим для них

4 основных структур данных для коллекций:
1. Map 
2. Set
3. Vector
4. List
Другие типы коллекций доступы через host-платформу

### Maps
`Map` — коллекция пар ключ/значение

В Clojure `Map`ы используют HashMap или SortedMap в качестве реализации

`HashMap` или `Hash (хэш)` так называется потому что внутри создается хэш ключа который мапится к нужному значению

`Поиск/вставка/удаление` на этой структуре данных быстры

`SortedMap` несколько отлична от `HashMap` тем что сохраняет порядок ключей. А так интерфейс взаимодействия с ними одинаков. `SortedMap`ы не так распространены.

Хэшмапа создаэтся через `{}` фигурные скобки

> Наличие запятой между парами ключ-значение — опционально, 
> но в свежесозданной хэшмапе при этом будут всё равно присутствовать запятые.

Другой способ создания мапы - использование `hash-map` ф-ии

####  Exercise 2.02: Using Maps

Мапы и кейворды могут использоваться как функции. 
Когда они находятся в позиции оператора `operator position`, т.е на первом месте в списке, то они используются в качестве ф-ии через которую можно искать в мапе

Через `assoc` можно добавить новый ключ в мапу. `assoc` вернёт новую мапу. При добавлении по имеющемуся ключу `assoc` заменит значение на новое. 

При необходимости обновить значение ключа можно использовать ф-ию `update`.  `update` позволяет вычислить новое значение ключа на основе предыдущего. `update` принимает коллбек в качестве 3 параметра

### Sets
`Set` — это коллекция уникальных значений

В кложе они имплементированы через `HashSet` и `SortedSet`

`Set` можно создать через литерал `#{1 2 3 4 5}` -> `#{1 4 3 2 5}`

Порядок в котором вернулся Set такой из-за внутренней реализации HashSet'a. Значения ключей преобразуются в хэш, который позволяет быстро искать по Set'у , но при это не хранится порядок при создании Set'a

В случае если важен порядок лучше использовать Вектор

`Set` также можно создать через вспомогательную ф-ию `hash-set`

Через `set` ф-ию можно создать `Set` из других коллекций

(set [:a :b :c])

Также `set` не выкинет эксепшен если встретит в переданной коллекции дублирующиеся ключи. Удобно использовать для дедуплиации ключей

`SortedSet` можно создать через `sorted-set`

Через `contains?` можно проверить наличе элемента в сете. Эта ф-ия вернёт `true` в случае если мы ищем nil в сете. В отличие от `get` ф-ии которая вернёт nil

Для добавления элемента в `Set` можно использовать `conj`

Для удаления можно использовать `disj`

### Vectors 
`Vector` — могущесвенный иммутабельный массив. Эта коллекция сохраняет порядок элементов.

`Vector` можно создать через литерал или ф-ию `vector`

Через `veс` можно создать вектор из других коллекций

`conj` при добавлении айтемов в вектор добавляет их в конец

У вектора можно достать айтем через ф-ию `get` по индексу
`(get [1 2 3] 0) ->> 1`

### Lists
`Lists (списки)` — такие же последовательные коллекции что и вектор, но с добавлением новых айтемов в начало списка

Поиск в листе по индексу медленнее чем в векторе 

В большинстве своём списки используются для того чтобы писать макросы и листинг программы. Или для реализации стека LIFO (Last In First Out)

Для отличия списка при записи кода и при создании структуры данных, нужно использовать префикс `'`

`List` можно создать через `list` ф-ию

 ### Collection and Sequence Abstractions
 
 В кложе есть два понятия: последовательность (`sequence`) и коллекция `collection`.
 
 `Последовательность (sequence)` — это набор элементов в определенном порядке, когда каждый элемент следует за другим. Это `Vector` и `List`.
 
Коллекциями в кложе являются все составные типы данных — `List, Vector, Map, Set`

####  Exercise 2.06: Working with Nested Data Structures
Через  (set! `*print-level* 2)` можно задать вложенность для выводы вложенных структур

Через `(set! *print-level* nil)` можно скинуть