# Chapter I
## Introduction
`Clojure` —  функционалный, краткий и элегантный язык семейства Лисп-языков c небольшой core-библиотекой и таким же небольшим синтаксисом.

 ## REPL Basics
 `Read Eval Print Loop` ака (`REPL`) — это короч CLI для взаимодействия с выполняющейся в текущий момент `Clojure` программой.
 
REPL  `**читает**`  юзер-инпут, `**исполняет**` его, компилируя и выполняя, затем `**печатает**`. Но REP — это только три буквы. Последняя буква происходит от слова `loop` когда я снова и снова повторяю процесс.

В кложе REPL вообще играет `исключительное` и `основополагающее` значение для разработчика. 

###  Exercise 1.02: Getting around in the REPL
`*1` — специальная переменная, которая сохраняет результат последнего выполненного выражения. `*2*`/`*3*` сохраняют 2 и 3 результаты.

`*e` — такая же специальная переменная, только она сохраняет последний эксепшен

Разные имплементации (хост-платформы) для Clojure могут возвращать для выражения `(\ 1 0)` разные результаты. Так в ClojureScript результатом будет `##Inf`

 `doc`, `find-doc` и `apropos` — функции для поиска по документации
 
1.  `doc` с помощью этой ф-ии можно по имени ф-ии найти её доку
 
`fully qualified name` — имя функции включая namespace

 Функции определенный в `clojure.core` неймспейсе доступы в текущем неймспейсе по-дефолту
 2.  `find-doc` можно юзать когда ты не знаешь имени ф-ии но имеешь представление о том что она может делать
 3.  `apropos` можно юзать чтобы найти функцию по её имени

##  Evaluation of Clojure Code
Lisp появился в 1958 году. Автор - Джон МакКарти.

Отличительная черта лиспа и его диалектов в том что код программы записывается с помощью структур данных языка.

Большое количество скобочек в коде list-программы от того что она использует списки

Основные строительные блоки Clojure — _`формы`_ и _`выражения`_.

> Заметочка для Мижгана
>
> Термины "форма" и "выражение" часто используются взаимозаменяемо; однако, согласно документации Clojure, "выражение" - это разновидность "формы": "Каждая форма, которая не обрабатывается _специальной_ для неё формой или макросом рассматривается компилятором в качестве "выражения" и поэтому вычисляется в некое значение"

**`s-expression`** — это такая запись данных и листинга программы, которая использует в качестве синтаксиа списки — (\* (+ 1 2 3) (- 10 3)), к примеру.

Часто в clojure(lisp) можно встретить слова `"Code is data"`.  Под этими словами понимается могущественная концепция, позволяющая программе генерировать код (также это определение подходит для термина `meta-programming (мета-программирование`).

##  Basic Special Forms
Специальные формы - это такие выражения, у которых есть специальные правила вычисления при компиляции исходного кода.

Например, функция **if** :
- Может не исполнять один из своих переданных аргументов в зависимости от результата исполнения первого аргумента

Есть и другие специальные **формы**:
-   **when**, выполнить переданное выражение в случае только когда условие ***truthy***
-   **do**, может выполнить серию выражений и вернуть значение последнего выражения
-   **def** и **let**, специальные формы, которые могут создавать **глобальные** и **локальные** байндинги (привязки)
-   **fn** и **defn**, специальные формы, которые могут создавать функции

###  Exercise 1.03: Working with if, do, and when

Специальную форму **do** можно юзать для работы с сайд-эффектами. Например, для логгинга или другого I/O (доступ к FS, DB запросы, запросы к сети и тп)

###  Bindings
В кложе используется термин *связывание (binding)*  нежели *переменная (variable)* и *присваивание (assignment)*, потому что мы намереваемся связать (bind) значение с символом только **единожды**.

**def** позволяет связать значение с символом

`(def x 10)`
`#'user/x`

Такой код возвращет ссылку на символ `x`
`user` — неймспейс в котором я её создал
`#'` — префикс с помощью которого мы можем показать саму ссылку, а не значение которое хранится в ней

В clojure возможно переопределить недавно созданную переменную

Через **`def`** создаются глобальные привязки значений

`(let [y 3] (println y) (* 10 y))`

**`let`** принимает вектор в первом параметре и создаёт локальные байндинги. Затем исполняет серию выражений будто мы используем `do` форму.

> Заметка
> **Вектор** похож на **список** тем что он тоже последовательная коллекция значений. Его нижележащая структура данных отличается. Записывается вектор через квадратные скобки **[1 2 3 4]**

###  Exercise 1.05: Creating Simple Functions with fn and defn

Комбинация специальных форм **def** и **fn** образует **defn**

Параметры, объявленные в векторе переменных — **ОБЯЗАТЕЛЬНЫЕ**
Если их все не передать, то кложа выкинет эксепшен

Через `doc-string`у можно задать описание к своей функции

## Truthiness, nil, and equality


