# Chapter 3
В Функциональном Программировании мы **избегаем** мутирования стейта

Функции в Clojure — `first-class-citizen` потому что их можно передавать, сохранять в переменных и возвращать из функций

Clojure заряжена на  продвинутые техники полиморфизма: использование мультиметодов и диспатч-функций.

##  Destructuring

Существует два способа деструктуризировать данные: последовательно (использую вектор), ассоциативно (используя мапу)

Когда ключи в мапе и символы в лете одинаково называются, можно использовать `:keys` для биндинга

`(defn print-coords [airport]  
	(let [{:keys [lat lon name]} airport]
		(println (str name " is located at Latitude: " lat " - " "Longitude: " lon))))`
		
		
### Ассоциативное деструктурирование

Через `:keys` можно достать ключи и забиндить их символам с такими же именами что и у ключей

 

## Higher-Order Programming

### Partial functions
Основные higher-order функи в clojure: 
- partial — принимает в качестве 1 аргумента функу и аргументы, возвращает новую функу
- [[comp]] — принимает n-ое кол-во фунок и вызывает их в обратном порядке, передавая результат из одной функи в другую
- apply — принимает функу и коллекцию аргументов которые потом применяет 

Как задать анонимную функу в Clojure? 
- Через `(fn [s] (str s))`
- Через `#(str %1 %2 %3)` — все переданные аргументы доступны под цифрами от 1 и далее

###  Exercise 3.04: High-Order Functions with Parenthmazes

`dispatch table` — это таблица указателей на функции

## Multimethods
Через мултиметоды можно в кложе имплементировать полиморфизм

`Полиморфизм` — это возможность кода (в контексте кложи это функи) вести себя по-разному в зависимости от контекста 

`Мультиметод` — это комбинация из диспатч-функи и одно или нескольких методов

Мультиметоды создаются через комбинацию двух операторов: `defmulti` и `defmethod`.

`defmulti` с помощью диспатч-функи решает какой метод должен быть выбран
`defmethod` реализует метод который будет выбран черзе диспатч-функу